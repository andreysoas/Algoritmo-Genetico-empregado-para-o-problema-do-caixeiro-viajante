# -*- coding: utf-8 -*-
"""AG empregado para o PCV.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17wNNlAxDDnTKIzNEhpokryQ0j_s2hLAy

Para a função de fitness foi reconhecido que quanto menor o valor de função objetivo para a solução, então maior será seu valor de fitness, logo, a função teria de ser decrescente com limite igual a zero, dessa forma, foi tomada uma função do tipo f(x) = 1/x , sendo x = valor de função objetivo para a solução

**fitness(solução) = 1/(Função Objetivo(solução))**

O método de seleção dos pais para crossover foi por meio de **Torneio com até 5 competidores**

O método de crossover implementado foi o **One point Crossover**.

**CÓDIGO FONTE**
"""

import numpy as np
import pandas as pd
import numpy.random as rd
from random import sample
from functools import reduce
import matplotlib.pyplot as plt
import math
plt.rcParams['figure.figsize']=(10,6)
rd.seed(43)

def Pop_inicial(x_0,pop_tam):
  populacao=[]
  i = 0
  while i<pop_tam:
    newIndividuo = sample(x_0,len(x_0))
    if newIndividuo not in populacao:
      populacao.append(newIndividuo)
      i+=1
  return populacao

def campeao(competidor):
  campeao=-1
  ind = -1
  for i in range(len(competidor)):
    if competidor[i] > campeao:
      campeao = competidor[i]
      ind = i
  return ind

def Torneio(populacao,M_distancias):
  pais = []
  pai_1=[]
  for i in range(2):
    to_fight = sample(populacao,5) #gera os competidores
    while pai_1 in to_fight:
      to_fight = sample(populacao,5)
    fit_competidores = []
    
    for i in to_fight:
      fit_competidores.append(fitness(i,M_distancias)) #preenchendo a lista dos fitness dos competidores
    indice_campeao = campeao(fit_competidores) #dado os cinco competidores, pega o indice do competidor com maior fitness
    pais.append(to_fight[indice_campeao]) #adiciona na lista de pais
    pai_1 = to_fight[indice_campeao] #adiciona a pai_1 para não aparecer em um próximo torneio
  
  return pais

def F_objetivo(individuo,M_distancias):
  soma=0
  for i in range(0,len(individuo)-1): 
    soma+=M_distancias[individuo[i]-1][individuo[i+1]-1]

  soma+=M_distancias[individuo[-1]-1][individuo[0]-1]

  return soma

def fitness(individuo,M_distancias):
  fitness = 1/(F_objetivo(individuo,M_distancias))
  return fitness

def Mutacao_2(filho,taxa):
  if rd.random()<=taxa:
    indice = rd.randint(0,len(filho))
    if indice<len(filho)-1:
      filho[indice],filho[indice+1]=filho[indice+1],filho[indice]
    else:
      filho[indice],filho[indice-1]=filho[indice-1],filho[indice]
  return filho

def Mutacao_3(filho,taxa):
  if rd.random()<=taxa:
    num_mutacoes = rd.randint(0,len(filho))
    for i in range(num_mutacoes):
      indice = rd.randint(0,len(filho))
      if indice<len(filho)-1:
        filho[indice],filho[indice+1]=filho[indice+1],filho[indice]
      else:
        filho[indice],filho[indice-1]=filho[indice-1],filho[indice]
  return filho

def OP_crossover(populacao,taxa_mutacao,tam_pop,M_distancias):
  new_pop = []
  for i in range(int(tam_pop/2)):
    pais = Torneio(populacao,M_distancias) # tem de retornar dois pais
    p1,p2=pais[0],pais[1]

    n = len(p1)
    mid = rd.randint(1,n-1)
    
  #FILHO 1
    ord_pai=p2[mid:]+p2[0:mid]
    filho_1 = p1[0:mid]

    for i in ord_pai:
      if i not in filho_1:
        filho_1.append(i)
    filho_1=Mutacao_3(filho_1,taxa_mutacao)
  #FILHO 2
    ord_pai=p1[mid:]+p1[0:mid]
    filho_2 = p2[0:mid]

    for i in ord_pai:
      if i not in filho_2:
        filho_2.append(i)  
    filho_2=Mutacao_3(filho_2,taxa_mutacao)
#adicionando os novos filhos à nova população
    new_pop.append(filho_1)
    new_pop.append(filho_2)

  return new_pop

def Minimo_pop(populacao):
  min = reduce(
      lambda minimo, atual: minimo if minimo[1] < atual[1] else atual,
      populacao)
  return min

def MinimoDosMinimos(minimos:list)->tuple:

  atual_min = Minimo_pop(minimos)
  minimos_lista = ([atual_min[0]],atual_min[1])

  for i in minimos:
    if i[0] not in minimos_lista[0]:
      if i[1] == atual_min[1]:
        minimos_lista[0].append(i[0])

  return minimos_lista

def Plot_minimos(Y,num_geracoes):
  x = np.arange(1,num_geracoes+1)
  y = Y

  plt.figure(figsize=(10, 6))


  plt.plot(x, y, "b")
  plt.xlabel("Geração", size = 16,)
  plt.ylabel("", size = 16)

  plt.title("Mínimo/Geração", 
          fontdict={'family': 'serif', 
                    'color' : 'darkblue',
                    'weight': 'bold',
                    'size': 18})

  plt.grid(True)
  plt.show()

def GA_PCV(var,M_distancias,taxa_mutacao,tam_pop,geracoes):
  #precisa da prob de mutação, da matriz de custos, do vetor indicando as cidades
  Y_to_plot = [] #guarda as tuplas com os minimos
  Y = [] #receberá só os valores dos mínimos para plotar

  populacao = Pop_inicial(var,tam_pop)
  print("Fundadores:\n",populacao,'\n')
  
  for i in range(geracoes):
    populacao=OP_crossover(populacao,taxa_mutacao,tam_pop,M_distancias)
    lista = []
    for j in populacao:
      lista.append((j,F_objetivo(j,M_distancias)))  #gera uma lista de tuplas com o individuo e o valor de função objetivo
    
    atual_minimo = Minimo_pop(lista)
    Y_to_plot.append(atual_minimo)             #adiciona à lista a tupla com menor valor de função objetivo
    #print("Geração ",i+1," :\n",populacao,'\n')
    

  Individuo_minimo = MinimoDosMinimos(Y_to_plot)          #Pega o mínimo da lista de mínimos de todas as gerações
  print("Melhor(es) indivíduo(s) encontrado(s): ",Individuo_minimo[0],"\n")
  print("Valor de função objetivo: ",Individuo_minimo[1])  

  # PLOT DO GRÁFICO DE MENORES SOLUÇÕES POR GERAÇÃO
  for i in range(len(Y_to_plot)):                  #Pega somente os valores dos mínimos por geração para plotar
    Y.append(Y_to_plot[i][1])
  
  Plot_minimos(Y,geracoes)